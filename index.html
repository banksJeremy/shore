<!doctype html>
<html lang=en>
	<head>
		<meta charset="utf-8">
		<title>Shore Math Engine</title>
		<link rel=stylesheet href=style.css>
		<script type="text/javascript" src="jquery-1.3.4.js"></script>
		<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7">
		<script type="text/javascript" src="mathjax/MathJax.js">
			MathJax.Hub.Config({
				extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
				jax: ["input/TeX", "output/HTML-CSS"],
				tex2jax: {
					inlineMath: [["\\(", "\\)"]],
					displayMath: [["\\[", "\\]"]]
				}
			})
		</script>
		<script type="text/javascript" src="parser.js"></script>
		<script type="text/javascript" src="coffeescript-0.9.4.js"></script>
		<script type="text/coffeescript">$ -> # jQuery on DOM ready...
			emPixels = ((element) ->
				"The approximate number of pixels per em in an element."
				
				test_element = $("<div>").css width: "10em"
				test_element.appendTo(element)
				result = parseFloat(test_element.css("width")) / 10
				test_element.remove()
				result
			) $("body") # this element
			
			occurences = (string, target_character) ->
				"The number of occurrences of a given character in a string."
				
				result = 0
				for character in string
					if character == target_character
						result += 1
				result
			
			scale_textarea = (textarea, modifier) ->
				"Set the height of a jQ textarea based on the newlines contained.
				
				(2 + newlines) ems."
				
				modifier ?= 0
				
				ems = occurences(textarea.val(), "\n") + 2 + modifier
				
				textarea.css "height", ems * emPixels
			
			input_box = $("#input")
			result_box = $("#results")
			form = $("form")
			
			input_box.focus()
			
			input_box.keypress (event) ->
				if event.which == 13 or event.which == 10
					if event.shiftKey
						$("form").submit()
						false
					else
						scale_textarea input_box, +1
						# where it most needs to be snappy
			
			input_box.keyup (event) -> scale_textarea input_box
			
			window.shore = shore =
				Value: class Value
					plus: (other) -> new shore.Sum [this, other]
					minus: (other) -> new shore.Sum [this, other.neg()]
					times: (other) -> new shore.Product [this, other]
					over: (other) -> new shore.Product [this, other.to_the shore.NEGATIVE_ONE]
					pos: -> this
					to_the: (other) -> new shore.Exponent this, other
					
					sub: -> alert "Taking subscripts of non-identifiers is not permitted."
					
					toString: -> @to_string()
					
					precedence: 0
					
					to_tex: (context) ->
						context ?= 1
						
						if @precedence < context
							"\\left(#{@to_free_tex()}\\right)"
						else
							@to_free_tex()
					
					to_string: (context) ->
						context ?= 0
						if @precedence < context
							"(#{@to_free_string()})"
						else
							@to_free_string()
				
				Number: class Number extends Value
					precedence: 10
					constructor: (@value) ->
					
					neg: -> new shore.Number -@value
					to_free_tex: -> "{#{String(@value)}}"
					to_free_string: -> String(@value)
				
				Identifier: class Identifier extends Value
					precedence: 10
					constructor: (@string_value, @tex_value) ->
						@tex_value ?= @string_value
					
					to_free_tex: -> @tex_value
					to_free_string: -> @string_value
					sub: (other) ->
						string = "{#{@string_value}}_#{other.to_string()}"
						tex = "{#{@tex_value}}_{#{other.to_tex()}}"
						new Identifier string, tex
				
				CANOperation: class CANOperation extends Value
					# Commutitive, Assocative N-ary Operation
					
					constructor: (@operands) ->
					to_free_tex: ->
						(operand.to_tex(@precedence) for operand in @operands).join(@tex_symbol)
					to_free_string: ->
						(operand.to_string(@precedence) for operand in @operands).join(@string_symbol)
				
				Sum: class Sum extends CANOperation
					precedence: 2
					
					string_symbol: " + "
					tex_symbol: " + "
				
				Product: class Product extends CANOperation
					precedence: 3
					
					string_symbol: " f "
					tex_symbol: " \\cdot "
				
				Exponent: class Exponent extends Value
					precedence: 3
					
					constructor: (@base, @exponent) ->
					
					to_free_tex: -> "{#{@base.to_tex(@precedence)}}^{#{@exponent.to_tex()}}"
					to_free_string: -> "#{@base.to_string(@precedence)}^#{@exponent.to_string()}"
					
			
			process_math = (input, output) ->
				parsed_input = parser.parse input
				
				tex_output = "\\[" + parsed_input.to_tex() + "\\]"
				output.text tex_output
				MathJax.Hub.Queue ["Typeset", MathJax.Hub, output.get(0) ]
			
			form.submit window.__go = ->
				input = $("#input").val()
				process_math input, result_box
				
				false # prevent form from being submitted normally
		</script>
	</head>
	<body>
		<div class=centering>
			<div class="content box">
				<h1>
					Shore <span>Math Engine</span>
				</h1>
				
				<form>
					<textarea id=input name=i>(3+3)*9</textarea>
					<div class=buttons>
						<input type=submit class=submit value="Calculate">
					</div>
				</form>
			</div>
			<div class="result box" id="results"></div>
			
			<div class=footer>
				Shore is developed by <a href="mailto:jeremy@jeremybanks.ca">Jeremy Banks</a>, the source and full credits are on <a href="http://github.com/jeremybanks/shore">on GitHub</a>.
			</div>
		</div>
	</body>
</html>
